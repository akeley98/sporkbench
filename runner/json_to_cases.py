from dataclasses import dataclass
import atexit
import json
import os
import sys
from warnings import warn

args_expect = "Expect .cpp output file, then list of .h filenames, then equal-length list of .json filenames"
if len(sys.argv) % 2 != 0:
    raise ValueError(args_expect)
cpp_out_fname = sys.argv[1]
h_fnames = sys.argv[2:len(sys.argv) // 2 + 1]
json_fnames = sys.argv[len(sys.argv) // 2 + 1:]
assert len(h_fnames) == len(json_fnames)
for fname in json_fnames:
    if not fname.endswith(".json"):
        raise ValueError(f"{fname!r}, {args_expect}")
for fname in h_fnames:
    if not fname.endswith(".h"):
        raise ValueError(f"{fname!r}, {args_expect}")
if not cpp_out_fname.endswith(".cpp"):
    raise ValueError(f"{cpp_out_fname!r}, {args_expect}")


int32_max = (1 << 31) - 1


gemm_supported_ABC_types = {
    ("f32", "f32", "f32"),
    ("f16", "f16", "f32"),
    ("f16", "f16", "f16"),
}

gemv_supported_ABC_types = {
    ("f32", "f32", "f32"),
}

ctype_table = {
    "f16": "__half",
    "f32": "float",
}


def get_positive_int(j_obj, key, default):
    n = j_obj.get(key, default)
    if isinstance(n, float):
        if int(n) == n:
            n = int(n)
    if isinstance(n, int) and n > 0:
        return n
    raise ValueError(f"{key}={n}; expected positive int")


def get_row_major(j_obj, key):
    n = j_obj.get(key, "<not provided>")
    if n == "row":
        return True
    if n == "col" or n == "column":
        return False
    raise ValueError(f'{key}={n}; expected "row" or "column" or "col"')


def get_ABC_types(j_obj, supported_ABC_types):
    types = (j_obj.get("A_type"), j_obj.get("B_type"), j_obj.get("C_type"))
    if types in supported_ABC_types:
        return types
    elif types == (None, None, None):
        warn("No explicit types, defaulting to f32: " + j_obj["proc"])
        return ("f32", "f32", "f32")
    else:
        raise ValueError(
            f"Missing or unsupported types: "
            f"A: {types[0]}, B: {types[1]}, C: {types[2]}"
        )


@dataclass(slots=True)
class GemmCase:
    cuda_arch: str
    json_name: str
    proc_name: str
    run_function: str
    flags: str
    L_divisor: int
    L_max: int
    M_divisor: int
    M_max: int
    N_divisor: int
    N_max: int
    K_split_divisor: int
    K_split_max: int
    K_cluster_divisor: int
    K_cluster_max: int
    A_type: str
    B_type: str
    C_type: str


@dataclass(slots=True)
class GemvCase:
    cuda_arch: str
    json_name: str
    proc_name: str
    run_function: str
    M_divisor: int
    M_max: int
    K_divisor: int
    K_max: int
    A_type: str
    B_type: str
    C_type: str


c_lines = []
user_gemm_cases = []
user_gemv_cases = []
proc_name_to_json = {}


c_lines.append(f"// Do not hand-edit.")
c_lines.append(f"// Generated by {__file__!r}")
c_lines.append('#include "sporkbench_cases.hpp"\n')
c_lines.append('#include <cuda_bf16.h>')
c_lines.append('#include <cuda_fp16.h>')
c_lines.append('#include <vector>\n')
for h_name in h_fnames:
    c_lines.append(f'#include "{h_name}"')
c_lines.append("\n\nnamespace sporkbench {\n")


# Functions for
#   * Adding C source code run_* function wrappers (wraps Exo gemm or gemv proc)
#   * Adding a case to user_gemm_cases or user_gemv_cases


gemm_split_k_keys = {
    "proc", "args", "algorithm", "A_major", "B_major", "C_major",
    "L_divisor", "L_max",
    "M_divisor", "M_max",
    "N_divisor", "N_max",
    "K_split_divisor", "K_split_max",
    "K_cluster_divisor", "K_cluster_max",
    "A_type", "B_type", "C_type",
}

gemm_no_split_k_keys = {
    "proc", "args", "algorithm", "row_major", "A_major", "B_major", "C_major",
    "L_divisor", "L_max",
    "M_divisor", "M_max",
    "N_divisor", "N_max",
    "K_divisor", "K_max",
    "A_type", "B_type", "C_type",
}

def add_gemm_case(fname, cuda_arch, j_obj):
    proc = j_obj["proc"]
    args = j_obj["args"]
    batch_support = "L" in args
    split_k_support = "K_split" in args and "K_cluster" in args
    if ("K" in args) == split_k_support:
        raise ValueError(f"Expect K argument alone XOR K_split and K_cluster arguments together")
    if split_k_support:
        K_divisor_key = "K_cluster_divisor"
        K_max_key = "K_cluster_max"
        allowed_keys = gemm_split_k_keys
    else:
        K_divisor_key = "K_divisor"
        K_max_key = "K_max"
        allowed_keys = gemm_no_split_k_keys
    for key in j_obj:
        if key not in allowed_keys:
            raise ValueError(f"Unknown key {key!r}, not in {allowed_keys!r}")

    ABC_types = get_ABC_types(j_obj, gemm_supported_ABC_types)

    flag_list = []
    if get_row_major(j_obj, "A_major"):
        flag_list.append("A_row_major_flag")
    if get_row_major(j_obj, "B_major"):
        flag_list.append("B_row_major_flag")
    if get_row_major(j_obj, "C_major"):
        flag_list.append("C_row_major_flag")
    flags = (" | ".join(flag_list)) or "0"

    case_obj = GemmCase(
        cuda_arch,
        fname,
        proc,
        "run_" + proc,
        flags,
        L_divisor=get_positive_int(j_obj, "L_divisor", 1),
        L_max=get_positive_int(j_obj, "L_max", int32_max if batch_support else 1),
        M_divisor=get_positive_int(j_obj, "M_divisor", 4),
        M_max=get_positive_int(j_obj, "M_max", int32_max),
        N_divisor=get_positive_int(j_obj, "N_divisor", 4),
        N_max=get_positive_int(j_obj, "N_max", int32_max),
        K_split_divisor=get_positive_int(j_obj, "K_split_divisor", 1),
        K_split_max=get_positive_int(j_obj, "K_split_max", int32_max if split_k_support else 1),
        K_cluster_divisor=get_positive_int(j_obj, K_divisor_key, 4),
        K_cluster_max=get_positive_int(j_obj, K_max_key, int32_max),
        A_type=ABC_types[0],
        B_type=ABC_types[1],
        C_type=ABC_types[2],
    )
    if not batch_support and case_obj.L_max != 1:
        raise ValueError(f"L argument must be listed if L_max != 1")

    # Generate run function
    c_args = ["ctxt"]
    for arg_name in args:
        if arg_name == "K":
            c_args.append("size.K_cluster")
        elif arg_name in ("L", "M", "N", "K_split", "K_cluster"):
            c_args.append(f"size.{arg_name}")
        elif arg_name in ("A", "B", "C"):
            c_args.append(arg_name)
        else:
            raise ValueError(f"Unknown arg name {arg_name!r}")
    CA = ctype_table[case_obj.A_type]
    CB = ctype_table[case_obj.B_type]
    CC = ctype_table[case_obj.C_type]
    c_lines.append(f"static void run_{proc}(cublasHandle_t, GemmSize size, const {CA}* A, const {CB}* B, {CC}* C)")
    c_lines.append("{")
    c_lines.append("    void* ctxt = nullptr;")
    c_lines.append(f"    {proc}({', '.join(c_args)});")
    c_lines.append("}\n")

    # Store gemm test case, to be added to the C++ array later.
    user_gemm_cases.append(case_obj)

gemv_keys = {
    "proc", "args", "algorithm",
    "M_divisor", "M_max",
    "K_divisor", "K_max",
    "A_type", "B_type", "C_type",
}

def add_gemv_case(fname, cuda_arch, j_obj):
    proc = j_obj["proc"]
    args = j_obj["args"]
    allowed_keys = gemv_keys

    for key in j_obj:
        if key not in allowed_keys:
            raise ValueError(f"Unknown key {key!r}, not in {allowed_keys!r}")

    ABC_types = get_ABC_types(j_obj, gemm_supported_ABC_types)

    case_obj = GemvCase(
        cuda_arch,
        fname,
        proc,
        "run_" + proc,
        M_divisor=get_positive_int(j_obj, "M_divisor", 4),
        M_max=get_positive_int(j_obj, "M_max", int32_max),
        K_divisor=get_positive_int(j_obj, "K_divisor", 4),
        K_max=get_positive_int(j_obj, "K_max", int32_max),
        A_type=ABC_types[0],
        B_type=ABC_types[1],
        C_type=ABC_types[2],
    )

    # Generate run function
    c_args = ["ctxt"]
    for arg_name in args:
        if arg_name == "K":
            c_args.append("size.K")
        elif arg_name == "M":
            c_args.append("size.M")
        elif arg_name in ("A", "x", "y"):
            c_args.append(arg_name)
        else:
            raise ValueError(f"Unknown arg name {arg_name!r}")

    c_lines.append(f"static void run_{proc}(cublasHandle_t, GemvSize size, const float* A, const float* x, float* y)")
    c_lines.append("{")
    c_lines.append("    void* ctxt = nullptr;")
    c_lines.append(f"    {proc}({', '.join(c_args)});")
    c_lines.append("}\n")

    # Store gemv test case, to be added to the C++ array later.
    user_gemv_cases.append(case_obj)


for fname in json_fnames:
    try:
        proc_name = None
        j = json.load(open(fname, "r"))
        fname_without_dir = os.path.split(fname)[1]
        underscore_split = fname_without_dir.split("_")
        assert len(underscore_split) >= 2
        assert underscore_split[0] == "exocc"
        cuda_arch = underscore_split[1]
        for j_obj in j:
            # Parse proc_name first so user has context for any subsequent errors.
            proc_name = j_obj["proc"]
            algorithm = j_obj["algorithm"]
            old_json = proc_name_to_json.get(proc_name)
            if old_json is not None:
                raise ValueError(f"proc name collision, previously added by {old_json!r}")
            proc_name_to_json[proc_name] = fname
            if algorithm == "gemm":
                add_gemm_case(fname, cuda_arch, j_obj)
            elif algorithm == "gemv":
                add_gemv_case(fname, cuda_arch, j_obj)
            else:
                raise ValueError(f"Unknown algorithm {algorithm!r}")
            # Reset before next loop iteration to avoid misleading error message.
            proc_name = None
    except Exception:
        @atexit.register
        def error_notify():
            print(f"\x1b[31m\x1b[1mjson_to_cases error in:\x1b[0m {fname!r}, proc={proc_name!r}", file=sys.stderr)
        raise


# Bucket GemmCase by type.
gemm_by_type = {types: [] for types in gemm_supported_ABC_types}
for gemm_case in user_gemm_cases:
    gemm_by_type[gemm_case.A_type, gemm_case.B_type, gemm_case.C_type].append(gemm_case)


# Generate user_gemm_cases arrays by type.
# We previously already generated the wrapper run_* functions.
for abc_types in sorted(gemm_supported_ABC_types):
    A, B, C = abc_types
    assert A == B
    c_lines.append(f"const std::vector<GemmCase_{C}_{A}>& get_user_cases(const GemmCase_{C}_{A}&)")
    c_lines.append("{")
    c_lines.append(f"  static const std::vector<GemmCase_{C}_{A}> result {{")
    for gemm_case in gemm_by_type[abc_types]:
        c_lines.append(f"  GemmCase_{C}_{A} {{")
        c_lines.append(f'    CudaArch::{gemm_case.cuda_arch},')
        c_lines.append(f'    {json.dumps(gemm_case.json_name)},')
        c_lines.append(f'    {json.dumps(gemm_case.proc_name)},')
        c_lines.append(f"    {gemm_case.run_function},")
        c_lines.append(f"    {gemm_case.flags},")
        c_lines.append(f"    {gemm_case.L_divisor}, {gemm_case.L_max},  // L")
        c_lines.append(f"    {gemm_case.M_divisor}, {gemm_case.M_max},  // M")
        c_lines.append(f"    {gemm_case.N_divisor}, {gemm_case.N_max},  // N")
        c_lines.append(f"    {gemm_case.K_split_divisor}, {gemm_case.K_split_max},  // K_split")
        c_lines.append(f"    {gemm_case.K_cluster_divisor}, {gemm_case.K_cluster_max},  // K_cluster")
        c_lines.append("  },")
    c_lines.append("  };\n")
    c_lines.append("  return result;\n")
    c_lines.append("}\n")


# Generate user_gemv_cases array.
# We previously already generated the wrapper run_* functions.
c_lines.append("static const GemvCase gemv_user_cases_array[] = {")
for gemv_case in user_gemv_cases:
    assert gemv_case.A_type == "f32"
    assert gemv_case.B_type == "f32"
    assert gemv_case.C_type == "f32"
    c_lines.append("  GemvCase{")
    c_lines.append(f'    CudaArch::{gemv_case.cuda_arch},')
    c_lines.append(f"    {json.dumps(gemv_case.json_name)},")
    c_lines.append(f"    {json.dumps(gemv_case.proc_name)},")
    c_lines.append(f"    {gemv_case.run_function},")
    c_lines.append(f"    {gemv_case.M_divisor}, {gemv_case.M_max},")
    c_lines.append(f"    {gemv_case.K_divisor}, {gemv_case.K_max},")
    c_lines.append("  },")
if not user_gemv_cases:
    c_lines.append("  {}")
c_lines.append("};\n")
c_lines.append("const std::vector<GemvCase>& get_user_cases(const GemvCase&)")
c_lines.append("{")
c_lines.append(f"  static const std::vector<GemvCase> result(&gemv_user_cases_array[0], &gemv_user_cases_array[{len(user_gemv_cases)}]);")
c_lines.append("  return result;")
c_lines.append("}")

c_lines.append("\n}  // end namespace")


# Write out C++ file.
os.makedirs(os.path.dirname(cpp_out_fname), exist_ok=True)
with open(cpp_out_fname, "w") as out_file:
    for cl in c_lines:
        print(cl, file=out_file)
