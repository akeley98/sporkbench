from dataclasses import dataclass
import atexit
import json
import os
import sys

args_expect = "Expect .cpp output file, then list of .h filenames, then equal-length list of .json filenames"
if len(sys.argv) % 2 != 0:
    raise ValueError(args_expect)
cpp_out_fname = sys.argv[1]
h_fnames = sys.argv[2:len(sys.argv) // 2 + 1]
json_fnames = sys.argv[len(sys.argv) // 2 + 1:]
assert len(h_fnames) == len(json_fnames)
for fname in json_fnames:
    if not fname.endswith(".json"):
        raise ValueError(f"{fname!r}, {args_expect}")
for fname in h_fnames:
    if not fname.endswith(".h"):
        raise ValueError(f"{fname!r}, {args_expect}")
if not cpp_out_fname.endswith(".cpp"):
    raise ValueError(f"{cpp_out_fname!r}, {args_expect}")


int32_max = (1 << 31) - 1


def get_positive_int(j_obj, key, default):
    n = j_obj.get(key, default)
    if isinstance(n, float):
        if int(n) == n:
            n = int(n)
    if isinstance(n, int) and n > 0:
        return n
    raise ValueError(f"{key}={n}; expected positive int")


def get_row_major(j_obj, key):
    n = j_obj.get(key, "<not provided>")
    if n == "row":
        return True
    if n == "col" or n == "column":
        return False
    raise ValueError(f'{key}={n}; expected "row" or "column" or "col"')


@dataclass(slots=True)
class GemmCase:
    cuda_arch: str
    json_name: str
    proc_name: str
    run_function: str
    flags: str
    L_divisor: int
    L_max: int
    M_divisor: int
    M_max: int
    N_divisor: int
    N_max: int
    K_split_divisor: int
    K_split_max: int
    K_cluster_divisor: int
    K_cluster_max: int


@dataclass(slots=True)
class GemvCase:
    cuda_arch: str
    json_name: str
    proc_name: str
    run_function: str
    M_divisor: int
    M_max: int
    K_divisor: int
    K_max: int


c_lines = []
user_gemm_cases = []
user_gemv_cases = []
proc_name_to_json = {}


c_lines.append(f"// Do not hand-edit.")
c_lines.append(f"// Generated by {__file__!r}")
c_lines.append('#include "sporkbench_cases.hpp"\n')
for h_name in h_fnames:
    c_lines.append(f'#include "{h_name}"')
c_lines.append("\n\nnamespace sporkbench {\n")


# Functions for
#   * Adding C source code run_* function wrappers (wraps Exo gemm or gemv proc)
#   * Adding a case to user_gemm_cases or user_gemv_cases


gemm_split_k_keys = {
    "proc", "args", "algorithm", "A_major", "B_major", "C_major",
    "L_divisor", "L_max",
    "M_divisor", "M_max",
    "N_divisor", "N_max",
    "K_split_divisor", "K_split_max",
    "K_cluster_divisor", "K_cluster_max",
}

gemm_no_split_k_keys = {
    "proc", "args", "algorithm", "row_major", "A_major", "B_major", "C_major",
    "L_divisor", "L_max",
    "M_divisor", "M_max",
    "N_divisor", "N_max",
    "K_divisor", "K_max",
}

def add_gemm_case(fname, cuda_arch, j_obj):
    proc = j_obj["proc"]
    args = j_obj["args"]
    batch_support = "L" in args
    split_k_support = "K_split" in args and "K_cluster" in args
    if ("K" in args) == split_k_support:
        raise ValueError(f"Expect K argument alone XOR K_split and K_cluster arguments together")
    if split_k_support:
        K_divisor_key = "K_cluster_divisor"
        K_max_key = "K_cluster_max"
        allowed_keys = gemm_split_k_keys
    else:
        K_divisor_key = "K_divisor"
        K_max_key = "K_max"
        allowed_keys = gemm_no_split_k_keys
    for key in j_obj:
        if key not in allowed_keys:
            raise ValueError(f"Unknown key {key!r}, not in {allowed_keys!r}")
    
    flag_list = []
    if get_row_major(j_obj, "A_major"):
        flag_list.append("A_row_major_flag")
    if get_row_major(j_obj, "B_major"):
        flag_list.append("B_row_major_flag")
    if get_row_major(j_obj, "C_major"):
        flag_list.append("C_row_major_flag")
    flags = (" | ".join(flag_list)) or "0"
    
    case_obj = GemmCase(
        cuda_arch,
        fname,
        proc,
        "run_" + proc,
        flags,
        L_divisor=get_positive_int(j_obj, "L_divisor", 1),
        L_max=get_positive_int(j_obj, "L_max", int32_max if batch_support else 1),
        M_divisor=get_positive_int(j_obj, "M_divisor", 4),
        M_max=get_positive_int(j_obj, "M_max", int32_max),
        N_divisor=get_positive_int(j_obj, "N_divisor", 4),
        N_max=get_positive_int(j_obj, "N_max", int32_max),
        K_split_divisor=get_positive_int(j_obj, "K_split_divisor", 1),
        K_split_max=get_positive_int(j_obj, "K_split_max", int32_max if split_k_support else 1),
        K_cluster_divisor=get_positive_int(j_obj, K_divisor_key, 4),
        K_cluster_max=get_positive_int(j_obj, K_max_key, int32_max),
    )
    if not batch_support and case_obj.L_max != 1:
        raise ValueError(f"L argument must be listed if L_max != 1")

    # Generate run function
    c_args = ["ctxt"]
    for arg_name in args:
        if arg_name == "K":
            c_args.append("size.K_cluster")
        elif arg_name in ("L", "M", "N", "K_split", "K_cluster"):
            c_args.append(f"size.{arg_name}")
        elif arg_name in ("A", "B", "C"):
            c_args.append(arg_name)
        else:
            raise ValueError(f"Unknown arg name {arg_name!r}")
    c_lines.append(f"static void run_{proc}(cublasHandle_t, GemmSize size, const float* A, const float* B, float* C)")
    c_lines.append("{")
    c_lines.append("    void* ctxt = nullptr;")
    c_lines.append(f"    {proc}({', '.join(c_args)});")
    c_lines.append("}\n")

    # Store gemm test case, to be added to the C++ array later.
    user_gemm_cases.append(case_obj)

gemv_keys = {
    "proc", "args", "algorithm",
    "M_divisor", "M_max",
    "K_divisor", "K_max",
}

def add_gemv_case(fname, cuda_arch, j_obj):
    proc = j_obj["proc"]
    case_obj = GemvCase(fname, proc, "run_" + proc)
    args = j_obj["args"]
    assert(0)  
    user_gemv_cases.append(case_obj)


for fname in json_fnames:
    try:
        proc_name = None
        j = json.load(open(fname, "r"))
        fname_without_dir = os.path.split(fname)[1]
        underscore_split = fname_without_dir.split("_")
        assert len(underscore_split) >= 2
        assert underscore_split[0] == "exocc"
        cuda_arch = underscore_split[1]
        for j_obj in j:
            # Parse proc_name first so user has context for any subsequent errors.
            proc_name = j_obj["proc"]
            algorithm = j_obj["algorithm"]
            old_json = proc_name_to_json.get(proc_name)
            if old_json is not None:
                raise ValueError(f"proc name collision, previously added by {old_json!r}")
            proc_name_to_json[proc_name] = fname
            if algorithm == "gemm":
                add_gemm_case(fname, cuda_arch, j_obj)
            elif algorithm == "gemv":
                add_gemv_case(fname, cuda_arch, j_obj)
            else:
                raise ValueError(f"Unknown algorithm {algorithm!r}")
            # Reset before next loop iteration to avoid misleading error message.
            proc_name = None
    except Exception:
        @atexit.register
        def error_notify():
            print(f"\x1b[31m\x1b[1mjson_to_cases error in:\x1b[0m {fname!r}, proc={proc_name!r}", file=sys.stderr)
        raise


# Generate user_gemm_cases array.
# We previously already generated the wrapper run_* functions.
c_lines.append(f"const int GemmCase::num_user_cases = {len(user_gemm_cases)};")
c_lines.append("const GemmCase GemmCase::user_cases[] = {")
for gemm_case in user_gemm_cases:
    c_lines.append("  GemmCase{")
    c_lines.append(f'    CudaArch::{gemm_case.cuda_arch},')
    c_lines.append(f'    {json.dumps(gemm_case.json_name)},')
    c_lines.append(f'    {json.dumps(gemm_case.proc_name)},')
    c_lines.append(f"    {gemm_case.run_function},")
    c_lines.append(f"    {gemm_case.flags},")
    c_lines.append(f"    {gemm_case.L_divisor}, {gemm_case.L_max},  // L")
    c_lines.append(f"    {gemm_case.M_divisor}, {gemm_case.M_max},  // M")
    c_lines.append(f"    {gemm_case.N_divisor}, {gemm_case.N_max},  // N")
    c_lines.append(f"    {gemm_case.K_split_divisor}, {gemm_case.K_split_max},  // K_split")
    c_lines.append(f"    {gemm_case.K_cluster_divisor}, {gemm_case.K_cluster_max},  // K_cluster")
    c_lines.append("  },")
if not user_gemm_cases:
    c_lines.append("  {}")
c_lines.append("};\n")


# Generate user_gemv_cases array.
# We previously already generated the wrapper run_* functions.
c_lines.append(f"const int GemvCase::num_user_cases = {len(user_gemv_cases)};")
c_lines.append("const GemvCase GemvCase::user_cases[] = {")
for gemv_case in user_gemv_cases:
    c_lines.append("  GemvCase{")
    c_lines.append(f'    CudaArch::{gemv_case.cuda_arch},')
    c_lines.append(f"    {json.dumps(gemv_case.json_name)},")
    c_lines.append(f"    {json.dumps(gemv_case.proc_name)},")
    c_lines.append(f"    {gemv_case.run_function},")
    c_lines.append(f"    {gemv_case.M_divisor}, {gemv_case.M_max},")
    c_lines.append(f"    {gemv_case.K_divisor}, {gemv_case.K_max},")
    c_lines.append("  },")
if not user_gemv_cases:
    c_lines.append("  {}")
c_lines.append("};\n")

c_lines.append("\n}  // end namespace")


# Write out C++ file.
os.makedirs(os.path.dirname(cpp_out_fname), exist_ok=True)
with open(cpp_out_fname, "w") as out_file:
    for cl in c_lines:
        print(cl, file=out_file)
